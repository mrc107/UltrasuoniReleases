/**
 * @OnlyCurrentDoc
 * This script syncs orders from Gmail to a Google Sheet.
 */

// CONFIGURATION
const ORDERS_TAB_NAME = "Orders"; 
const NEWS_TAB_NAME = "News";     

// LABELS
const ORDER_LABEL = "ultrasuoni/ordini/sent"; 
const NEWS_LABEL = "ultrasuoni/news";         

const VENDOR_EMAIL = "ultrasuonirecord@gmail.com";

/**
 * Creates a menu item in the spreadsheet when it's opened.
 */
function onOpen() {
  SpreadsheetApp.getUi()
    .createMenu('Ultrasuoni Tools')
    .addItem('1. Full Sync (Setup + Orders & News)', 'fullSync')
    .addItem('2. Sync Orders Only', 'syncOrdersOnly')
    .addItem('3. Sync News Only', 'syncNewsOnly')
    .addItem('4. Update Release Dates (Orders Only)', 'updateReleaseDatesFromSubject')
    .addSeparator()
    .addItem('5. Force Cleanup & Fix Titles', 'formatAndFixSheet')
    .addToUi();
}

/**
 * Ensures the sheets and headers exist before running any sync.
 */
function ensureSheetStructure() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  if (!ss) return false;

  const headers = ["Title (auto)", "MANUAL: Release date", "MANUAL: Price", "deejay.de URL", "bandcamp.com URL", "Other URL", "Email Date", "Email Thread ID"];

  // Setup Orders Tab
  let orderSheet = ss.getSheetByName(ORDERS_TAB_NAME);
  if (!orderSheet) {
    orderSheet = ss.insertSheet(ORDERS_TAB_NAME);
    orderSheet.getRange(1, 1, 1, headers.length).setValues([headers]).setFontWeight("bold");
  } else if (orderSheet.getLastRow() === 0) {
    orderSheet.getRange(1, 1, 1, headers.length).setValues([headers]).setFontWeight("bold");
  }

  // Setup News Tab
  let newsSheet = ss.getSheetByName(NEWS_TAB_NAME);
  if (!newsSheet) {
    newsSheet = ss.insertSheet(NEWS_TAB_NAME);
    newsSheet.getRange(1, 1, 1, headers.length).setValues([headers]).setFontWeight("bold");
  } else if (newsSheet.getLastRow() === 0) {
    newsSheet.getRange(1, 1, 1, headers.length).setValues([headers]).setFontWeight("bold");
  }
  
  return true;
}

/**
 * Wrapper: Runs the full sync (Orders then News).
 * Handles auto-restart logic.
 */
function fullSync() {
  // 1. Clear any existing triggers to prevent duplicates/loops
  const triggers = ScriptApp.getProjectTriggers();
  for (let i = 0; i < triggers.length; i++) {
    ScriptApp.deleteTrigger(triggers[i]);
  }

  // 2. Run the sync logic in interactive mode (show alerts)
  executeSync(true);
}

/**
 * This function is called automatically by the trigger if the script times out.
 */
function resumeSync() {
  // Run in background mode (no alerts)
  executeSync(false);
}

/**
 * Core logic for running the sync with restart capability.
 * @param {boolean} isInteractive - If true, shows UI alerts. If false, logs to console.
 */
function executeSync(isInteractive) {
  if (!ensureSheetStructure()) return;
  
  const startTime = new Date().getTime();

  // 1. Sync Orders
  const orderQuery = `label:${ORDER_LABEL} from:me`;
  const ordersFinished = syncLabelToSheet(ORDERS_TAB_NAME, orderQuery, true, startTime);

  // If Orders timed out, schedule restart and exit
  if (!ordersFinished) {
    scheduleRestart(isInteractive);
    return;
  }

  // 2. Sync News (Only if Orders finished)
  const newsQuery = `label:${NEWS_LABEL}`;
  const newsFinished = syncLabelToSheet(NEWS_TAB_NAME, newsQuery, false, startTime);

  // If News timed out, schedule restart and exit
  if (!newsFinished) {
    scheduleRestart(isInteractive);
    return;
  }

  // If we get here, everything finished successfully. Now we Clean Up.
  if (isInteractive) {
    // Only show toast, let the alert happen at the very end
    SpreadsheetApp.getActiveSpreadsheet().toast("Sync done. Cleaning up titles...", "Ultrasuoni Sync");
  }
  
  formatAndFixSheet(); // <--- AUTOMATIC CLEANUP
  
  if (isInteractive) {
    SpreadsheetApp.getUi().alert("Full Sync & Cleanup complete.");
  } else {
    Logger.log("Full Sync & Cleanup complete (via auto-restart).");
  }
}

/**
 * Helper to create the restart trigger.
 */
function scheduleRestart(isInteractive) {
  // Create a trigger to run 'resumeSync' in ~30 seconds
  ScriptApp.newTrigger('resumeSync')
           .timeBased()
           .after(30 * 1000)
           .create();
  
  if (isInteractive) {
    SpreadsheetApp.getUi().alert("Time limit reached. \n\nThe script has saved progress and scheduled an Auto-Restart in 30 seconds to finish the rest.\n\nYou can close this message.");
  } else {
    Logger.log("Time limit reached. Auto-Restart scheduled.");
  }
}

/**
 * Wrapper: Syncs Orders Only.
 */
function syncOrdersOnly() {
  if (!ensureSheetStructure()) return;
  const startTime = new Date().getTime();
  const orderQuery = `label:${ORDER_LABEL} from:me`;
  syncLabelToSheet(ORDERS_TAB_NAME, orderQuery, true, startTime);
  
  formatAndFixSheet(); // <--- AUTOMATIC CLEANUP
  SpreadsheetApp.getUi().alert("Orders Sync & Cleanup complete.");
}

/**
 * Wrapper: Syncs News Only.
 */
function syncNewsOnly() {
  if (!ensureSheetStructure()) return;
  const startTime = new Date().getTime();
  const newsQuery = `label:${NEWS_LABEL}`;
  syncLabelToSheet(NEWS_TAB_NAME, newsQuery, false, startTime);
  
  formatAndFixSheet(); // <--- AUTOMATIC CLEANUP
  SpreadsheetApp.getUi().alert("News Sync & Cleanup complete.");
}


/**
 * Reusable function to sync a specific Gmail query to a specific Sheet tab.
 */
function syncLabelToSheet(tabName, query, requireFromMe, startTime) {
  const myEmail = Session.getActiveUser().getEmail();
  const TIME_LIMIT_MS = 270000; 
  
  const headers = ["Title (auto)", "MANUAL: Release date", "MANUAL: Price", "deejay.de URL", "bandcamp.com URL", "Other URL", "Email Date", "Email Thread ID"];
  
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheet = ss.getSheetByName(tabName);
  
  const dataRange = sheet.getDataRange();
  const values = dataRange.getValues();
  
  // Maps to track existing links to prevent duplicates
  const existingDeejayLinks = new Set(values.map(row => row[3]).filter(String)); 
  const existingBandcampLinks = new Set(values.map(row => row[4]).filter(String)); 
  const existingOtherLinks = new Set(values.map(row => row[5]).filter(String));
  
  Logger.log(`Syncing [${tabName}] with query: ${query}`);
  const threads = GmailApp.search(query, 0, 100);
  
  const deejayRegex = /https?:\/\/www\.deejay\.de\/[^ \n\r\t<>"]+/gi;
  const bandcampRegex = /https?:\/\/[^\s\/]+\.bandcamp\.com\/[^ \n\r\t<>"]+/gi;
  const genericUrlRegex = /https?:\/\/[^ \n\r\t<>"]+/gi;
  
  const junkDomains = ["google.com", "facebook.com", "instagram.com", "twitter.com", "x.com", "youtube.com", "linkedin.com", "spotify.com", "apple.com", "t.me", "whatsapp.com", "unsubscribe", "preference", "account", "login", "signin", "w3.org", "schema.org", "uova", "mrcpr", "hghlndr"];

  let newRows = [];
  let startRow = sheet.getLastRow() + 1;
  let timeExpired = false;

  for (const thread of threads) {
    if ((new Date().getTime() - startTime) > TIME_LIMIT_MS) {
      timeExpired = true;
      break; 
    }

    const messages = thread.getMessages();
    let foundDeejay = new Set();
    let foundBandcamp = new Set();
    let foundOther = new Set();

    for (const message of messages) {
      if (requireFromMe && !message.getFrom().includes(myEmail)) continue; 

      const body = message.getPlainBody();
      
      (body.match(deejayRegex) || []).forEach(l => foundDeejay.add(l));
      (body.match(bandcampRegex) || []).forEach(l => foundBandcamp.add(l));
      
      const genericMatches = body.match(genericUrlRegex) || [];
      for (const link of genericMatches) {
        if (link.indexOf("http", 4) > -1) continue; 

        if (!link.match(deejayRegex) && !link.match(bandcampRegex)) {
          const lowerLink = link.toLowerCase();
          if (!junkDomains.some(domain => lowerLink.includes(domain))) {
            foundOther.add(link);
          }
        }
      }
    }

    const hasPriorityLinks = (foundDeejay.size > 0 || foundBandcamp.size > 0);
    const lastMessageDate = messages[messages.length - 1].getDate();
    const threadId = thread.getId();
    
    let currentRow = startRow + newRows.length;

    // Deejay
    for (const link of foundDeejay) {
      if (!existingDeejayLinks.has(link)) {
        const titleFormula = `=IF(NOT(ISBLANK(D${currentRow})), IFERROR(IMPORTXML(D${currentRow}, "//title[1]"), "Title Failed"), "")`;
        newRows.push([titleFormula, "", "", link, "", "", lastMessageDate, threadId]);
        existingDeejayLinks.add(link); 
        currentRow++;
      }
    }
    // Bandcamp
    for (const link of foundBandcamp) {
      if (!existingBandcampLinks.has(link)) {
        const titleFormula = `=IF(NOT(ISBLANK(E${currentRow})), IFERROR(IMPORTXML(E${currentRow}, "//title[1]"), "Title Failed"), "")`;
        newRows.push([titleFormula, "", "", "", link, "", lastMessageDate, threadId]);
        existingBandcampLinks.add(link); 
        currentRow++;
      }
    }
    // Other
    if (!hasPriorityLinks && foundOther.size > 0) {
      const firstOtherLink = Array.from(foundOther)[0]; 
      if (!existingOtherLinks.has(firstOtherLink)) {
        const titleFormula = `=IF(NOT(ISBLANK(F${currentRow})), IFERROR(IMPORTXML(F${currentRow}, "//title[1]"), "Title Failed"), "")`;
        newRows.push([titleFormula, "", "", "", "", firstOtherLink, lastMessageDate, threadId]);
        existingOtherLinks.add(firstOtherLink);
        currentRow++;
      }
    }
  }
  
  if (newRows.length > 0) {
    sheet.getRange(startRow, 1, newRows.length, headers.length).setValues(newRows);
  }
  
  SpreadsheetApp.flush();
  return !timeExpired;
}


function updateReleaseDatesFromSubject() {
  const ui = SpreadsheetApp.getUi();
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  if (!ss) return;

  const sheet = ss.getSheetByName(ORDERS_TAB_NAME);
  if (!sheet) {
    ui.alert(`Sheet "${ORDERS_TAB_NAME}" not found.`);
    return;
  }
  
  const range = sheet.getDataRange();
  const values = range.getValues();
  let updatesMade = 0;
  
  for (let i = 1; i < values.length; i++) {
    const row = values[i];
    let releaseDateB = row[1]; 
    const threadIdH = row[7];    
    
    if (threadIdH && (releaseDateB === "" || releaseDateB === null)) {
      try {
        const thread = GmailApp.getThreadById(threadIdH);
        const subject = thread.getFirstMessageSubject();
        const extractedMonth = extractMonthFromSubject(subject);
        if (extractedMonth) {
          sheet.getRange(i + 1, 2).setValue(extractedMonth); 
          updatesMade++;
        }
      } catch (e) {
        Logger.log(`Failed to process thread ID ${threadIdH}: ${e}`);
      }
    }
  }
  ui.alert(`Finished updating release dates. Updated ${updatesMade} rows in Orders.`);
}

/**
 * NEW FUNCTION: Cleans up, fixes titles, creates hyperlinks, and hides columns.
 * Optimized for batch processing.
 */
function formatAndFixSheet() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  
  // Process both tabs
  [ORDERS_TAB_NAME, NEWS_TAB_NAME].forEach(tabName => {
    const sheet = ss.getSheetByName(tabName);
    if (!sheet) return;

    Logger.log(`Formatting sheet: ${tabName}`);
    
    // 1. Normalize Columns (Auto Resize)
    sheet.autoResizeColumns(1, 8);
    
    // 2. Hide Deejay (Col 4/D) and Bandcamp (Col 5/E) columns
    sheet.hideColumns(4); // Hide D
    sheet.hideColumns(5); // Hide E
    sheet.showColumns(6);

    // 3. Fix Titles and Hyperlinks
    const lastRow = sheet.getLastRow();
    if (lastRow < 2) return; // No data

    // Get values and formulas in batch for speed
    const range = sheet.getRange(2, 1, lastRow - 1, 6);
    const values = range.getValues();
    const formulas = sheet.getRange(2, 1, lastRow - 1, 1).getFormulas();
    
    let updatesNeeded = false;
    let newFormulas = [];

    for (let i = 0; i < values.length; i++) {
      const row = values[i];
      const currentFormula = formulas[i][0];
      
      let titleCellVal = row[0];
      const deejayUrl = row[3];
      const bandcampUrl = row[4];
      const otherUrl = row[5];
      
      // Determine active URL
      let activeUrl = deejayUrl || bandcampUrl || otherUrl;
      
      if (!activeUrl) {
        newFormulas.push([currentFormula]); // Keep existing
        continue;
      }

      // Check if this row is ALREADY a hyperlink formula. If so, skip fetching unless broken.
      if (currentFormula && currentFormula.startsWith("=HYPERLINK")) {
        newFormulas.push([currentFormula]);
        continue;
      }

      // Check if Title needs fixing
      const needsFetch = (titleCellVal === "Title Failed" || titleCellVal === "#N/A" || titleCellVal === "" || titleCellVal === "Loading..." || titleCellVal === "Unknown Title" || (typeof titleCellVal === 'string' && titleCellVal.startsWith("Link Error")));

      let cleanTitle = titleCellVal;

      if (needsFetch) {
        try {
          const options = {
            'muteHttpExceptions': true,
            'headers': {
              'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.0.0 Safari/537.36',
              'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8',
              'Accept-Language': 'en-US,en;q=0.5',
            }
          };
          const response = UrlFetchApp.fetch(activeUrl, options);
          
          if (response.getResponseCode() === 200) {
            const html = response.getContentText();
            const match = html.match(/<title[^>]*>([\s\S]*?)<\/title>/i);
            if (match && match[1]) {
              cleanTitle = match[1].trim()
                .replace(/&amp;/g, "&").replace(/&quot;/g, '"')
                .replace(/&#39;/g, "'").replace(/&lt;/g, "<").replace(/&gt;/g, ">")
                .replace(/\n/g, " ");
            } else {
              cleanTitle = generateTitleFromUrl(activeUrl);
            }
          } else {
             cleanTitle = generateTitleFromUrl(activeUrl);
          }
        } catch (e) {
          cleanTitle = generateTitleFromUrl(activeUrl);
        }
      }
      
      // Create Hyperlink Formula
      // Use cleaned title, or if it was already good, use the existing value.
      // If title is still empty/bad after fetch attempt, use generated title.
      if (!cleanTitle || cleanTitle === "#N/A" || cleanTitle === "Title Failed") {
         cleanTitle = generateTitleFromUrl(activeUrl);
      }

      const safeTitle = cleanTitle.toString().replace(/"/g, '""');
      const formula = `=HYPERLINK("${activeUrl}", "${safeTitle}")`;
      
      newFormulas.push([formula]);
      updatesNeeded = true;
    }

    // Write back to sheet in ONE batch operation (Fast!)
    if (updatesNeeded) {
      sheet.getRange(2, 1, newFormulas.length, 1).setFormulas(newFormulas);
    }
  });
}


function extractMonthFromSubject(subject) {
  const lowerSubject = subject.toLowerCase();
  const monthMap = {
    "jan": "January", "january": "January",
    "feb": "February", "february": "February",
    "mar": "March", "march": "March",
    "apr": "April", "april": "April",
    "may": "May", 
    "jun": "June", "june": "June",
    "jul": "July", "july": "July",
    "aug": "August", "august": "August",
    "sep": "September", "sept": "September", "september": "September",
    "oct": "October", "october": "October",
    "nov": "November", "november": "November",
    "dec": "December", "december": "December"
  };
  const monthsRegex = Object.keys(monthMap).join('|');
  const dateRegex = new RegExp(`(\\d{1,2})?[\\s\\.\\-]*\\b(${monthsRegex})\\b`, 'i');
  const dateMatch = lowerSubject.match(dateRegex);

  if (dateMatch) {
    const day = dateMatch[1] ? dateMatch[1].trim() : "";
    let monthKey = dateMatch[2].toLowerCase(); 
    let month = monthMap[monthKey]; 
    return day ? day + " " + month : month; 
  }
  return ""; 
}

function generateTitleFromUrl(url) {
  try {
    let path = url.replace(/^https?:\/\/[^\/]+\//i, '');
    path = path.split('?')[0];
    if (path.endsWith('/')) path = path.slice(0, -1);
    path = path.replace(/\.(html|php|asp|jpg|png)$/i, '');
    let segments = path.split('/');
    let slug = segments[segments.length - 1];
    if (!slug || slug.trim() === "") return url;
    slug = slug.replace(/^\d+[-_]/, '');
    slug = slug.replace(/[-_]/g, ' ');
    return slug.replace(/\w\S*/g, function(txt){return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();});
  } catch (e) {
    return url; 
  }
}
